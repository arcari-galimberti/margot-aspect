//
// Created by leonardoarcari on 15/06/17.
//

#ifndef ASPECT_PROJECT_TUNERELEMENTS_H
#define ASPECT_PROJECT_TUNERELEMENTS_H

#include <memory>
#include <string>

namespace ag {

/**
 * Enum class to list the possible PredicateType for a SimplePredicate.
 */
enum class PredicateType { EQ, NEQ, GT, LT, GTE, LTE };

/**
 * This interface describes a Predicate. A Predicate exposes a method to
 * generate C++ code to test a control variable against a value according to
 * some relational operator. <br>
 * <i>E.g.: a call to Predicate::generateCondition of a predicate that tests
 * equality of a variable *a* against value 5 should return the following
 * string: *a == 5*</i>
 * <br>
 * As a utility method, a Predicate must also expose a *clone()* method to build
 * a deep-copy of itself.
 */
struct Predicate {
public:
  /**
   * Generates C++ code to test \p controlVar against some value according to
   * some relational operator.
   * @param [in] controlVar name of the control variable to predicate on.
   * @return a std::string containing a C++ boolean expression.
   */
  virtual std::string
  generateCondition(const std::string &controlVar) const = 0;

  /**
   * @return A heap-allocated deep-copy of this Predicate.
   */
  virtual std::unique_ptr<Predicate> clone() const = 0;
};

/**
 * A SimplePredicate is a Predicate whose test is a simple comparison between a
 * control variable and a value. Possible tests are:
 *  - Equality ( == )
 *  - Inequality ( != )
 *  - Greater than ( > )
 *  - Greater than or equal to ( >= )
 *  - Less than ( < )
 *  - Less than or equal to ( <= )
 * <br>
 * SimplePredicate is move-constructable
 */
struct SimplePredicate : public Predicate {
public:
  /**
   * SimplePredicate constructor
   * @param [in] operand value which to compare a control variable against.
   * @param [in] type the PredicateType of this SimplePredicate
   */
  SimplePredicate(const std::string &operand, PredicateType type);

  /**
   * Move constructor
   * @param [in] other the SimplePredicate object to move into this.
   */
  SimplePredicate(SimplePredicate &&other);

  /**
   * @see Predicate::generateCondition
   * Generates a C++ boolean expression testing \p controlVar against the
   * operand defined in the constructor. E.g.: if _type_ is PredicateType::NEQ,
   * _operand_ is 5 and \p controlVar is a then this method returns
   * <i>a != 5</a>
   * @param [in] controlVar name of the control variable to predicate on.
   * @return a std::string containing a C++ boolean expression.
   */
  std::string generateCondition(const std::string &controlVar) const override;

  /**
   * @return A heap-allocated deep-copy of this SimplePredicate
   */
  std::unique_ptr<Predicate> clone() const override;

private:
  PredicateType _type;
  std::string _operand;
};

/**
 * An AndPredicate is a Predicate that generates the logic conjunction of two
 * other Predicate objects.
 * <br>
 * AndPredicate is move-constructable
 */
struct AndPredicate : public Predicate {
  /**
   * AndPredicate constructor
   * @param [in] lhp the left hand Predicate of the conjunction
   * @param [in] rhp the right hand Predicate of the conjunction
   */
  AndPredicate(std::unique_ptr<Predicate> lhp, std::unique_ptr<Predicate> rhp);

  /**
   * Move constructor
   * @param [in] other the AndPredicate object to move into this.
   */
  AndPredicate(AndPredicate &&other);

  /**
   * @see Predicate::generateCondition
   * Generates a C++ boolean expression joining with logical *and* the boolean
   * expressions recursively generated by the left and right hand Predicates.
   * \p controlVar here is forwarded to the two predicates to generate their
   * boolean expression.
   * @param [in] controlVar name of the control variable to predicate on.
   * @return a std::string containing a C++ boolean expression.
   */
  std::string generateCondition(const std::string &controlVar) const override;

  /**
   * @return A heap-allocated deep-copy of this AndPredicate
   */
  std::unique_ptr<Predicate> clone() const override;

private:
  std::unique_ptr<Predicate> _lhp;
  std::unique_ptr<Predicate> _rhp;
};

/**
 * An OrPredicate is a Predicate that generates the logic disjunction of two
 * other Predicate objects.
 * <br>
 * OrPredicate is move-constructable
 */
struct OrPredicate : public Predicate {
  /**
   * OrPredicate constructor
   * @param [in] lhp the left hand Predicate of the disjunction
   * @param [in] rhp the right hand Predicate of the disjunction
   */
  OrPredicate(std::unique_ptr<Predicate> lhp, std::unique_ptr<Predicate> rhp);

  /**
   * Move constructor
   * @param [in] other the OrPredicate object to move into this.
   */
  OrPredicate(OrPredicate &&other);

  /**
   * @see Predicate::generateCondition
   * Generates a C++ boolean expression joining with logical *or* the boolean
   * expressions recursively generated by the left and right hand Predicates.
   * \p controlVar here is forwarded to the two predicates to generate their
   * boolean expression.
   * @param [in] controlVar name of the control variable to predicate on.
   * @return a std::string containing a C++ boolean expression.
   */
  std::string generateCondition(const std::string &controlVar) const override;

  /**
   * @return A heap-allocated deep-copy of this OrPredicate
   */
  std::unique_ptr<Predicate> clone() const override;

private:
  std::unique_ptr<Predicate> _lhp;
  std::unique_ptr<Predicate> _rhp;
};

/**
 * An NotPredicate is a Predicate that generates the logic negation of another
 * Predicate object.
 * <br>
 * NotPredicate is move-constructable
 */
struct NotPredicate : public Predicate {
public:
  /**
   * NotPredicate constructor.
   * @param [in] pred the Predicate object to negate.
   */
  NotPredicate(std::unique_ptr<Predicate> pred);

  /**
   * Move constructor
   * @param [in] other the NotPredicate object to move into this.
   */
  NotPredicate(NotPredicate &&other);

  /**
   * @see Predicate::generateCondition
   * Generates a C++ boolean expression logically negating the boolean
   * expression recursively generated by the Predicate passed in the
   * constructor. \p controlVar here is forwarded to that predicate to generate
   * its own boolean expression.
   * @param [in] controlVar name of the control variable to predicate on.
   * @return a std::string containing a C++ boolean expression.
   */
  std::string generateCondition(const std::string &controlVar) const override;

  /**
   * @return A heap-allocated deep-copy of this NotPredicate
   */
  std::unique_ptr<Predicate> clone() const override;

private:
  std::unique_ptr<Predicate> _pred;
};

/**
 * A Rule is a fundamental part of a <*-tuner> element. It defines under which
 * condition a particular value must be set either as *new goal* or as *new
 * state*, depending on the Tuner that requires this Rule (e.g.: <goal-tuner>
 * or <state-tuner>).
 * <br>
 * Rule is copy-constructable and move-constructable.
 */
struct Rule {
public:
  /**
   * Rule constructor.
   * @param [in] value a string representation of the value to set in case
   *             \p predicate is true.
   * @param [in] predicate the Predicate under which condition this Rule
   *             applies.
   */
  Rule(const std::string &value, std::unique_ptr<Predicate> predicate);

  /**
   * Copy constructor.
   * @param [in] other the Rule object to copy into this.
   */
  Rule(const Rule &other);

  /**
   * Move constructor.
   * @param [in] other the Rule object to move into this.
   */
  Rule(Rule &&rule);

  /**
   * Value getter.
   * @return a string representation of the value to set in case
   *         Rule::predicate() is true
   */
  const std::string &value() const;
  /**
   * Predicate getter.
   * @return the Predicate under which condition this Rule applies.
   */
  const Predicate &predicate() const;

private:
  std::string _value;
  std::unique_ptr<Predicate> _predicate;
};

/**
 * ControlVar represents the <control-var> XML element. It's described by
 * the pair (variableType, variableName).
 * <br>
 * ControlVar is copy-constructable and move-constructable.
 */
struct ControlVar {
public:
  /**
   * ControlVar constructor.
   * @param _type the ControlVar type.
   * @param _name the ControlVar name.
   */
  ControlVar(const std::string &_type, const std::string &_name);

  /**
   * Copy constructor.
   * @param [in] other the ControlVar object to copy into this.
   */
  ControlVar(const ControlVar &other);

  /**
   * Move constructor.
   * @param [in] other the ControlVar object to move into this.
   */
  ControlVar(ControlVar &&other);

  /**
   * Type getter.
   * @return the ControlVar type.
   */
  const std::string &type() const;

  /**
   * Name getter.
   * @return the ControlVar name.
   */
  const std::string &name() const;

private:
  std::string _type;
  std::string _name;
};

/**
 * Argument represents the <argument> XML element. It's described by
 * the triple (argumentType, argumentName, isSoftwareKnob).
 * isSoftwareKnob should be true in case this Argument is a mARGOt software
 * knob, otherwise, if this is a traditional function argument, it should be
 * false.
 */
class Argument {
public:
  /**
   * Argument Constructor
   * @param [in] type the Argument type.
   * @param [in] name the Argument name.
   * @param [in] swKnob true if this Argument is a software knob.
   *             False otherwise.
   */
  Argument(const std::string &type, const std::string &name, const bool &swKnob)
      : _type(type), _name(name), _swKnob(swKnob){};

  /**
   * Type getter.
   * @return the Argument type.
   */
  const inline std::string &type() const { return _type; }

  /**
   * Name getter.
   * @return the Argument name.
   */
  const inline std::string &name() const { return _name; }

  /**
   * isSoftwareKnob property getter.
   * @return true if this Argument is a software knob. False otherwise.
   */
  inline bool swKnob() const { return _swKnob; }

private:
  std::string _type;
  std::string _name;
  bool _swKnob;
};
}

#endif // ASPECT_PROJECT_TUNERELEMENTS_H
